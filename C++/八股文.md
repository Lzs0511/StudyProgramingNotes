### 栈和堆的区别

堆是由程序员手动开辟和手动释放的，如果申请内存之后不释放，那么很有可能会发生内存泄漏。栈是由操作系统自动分配和释放的。

堆在内存空间中的生长方向是向上的，内存地址由低到高增长。栈在内存空间中的生长方向是向下的，内存地址由高向低增长。

堆的空间大，而栈的内存空间比较小。堆在进程中可申请的大小大概是进程虚拟内存的大小，而栈的大小跟系统栈有关，比如在64位linux系统中，系统栈大小默认为8M或者10M。

分配的效率也不同，栈是由操作系统分配和释放的，并且在硬件层面提供了支持，比如说有专门的寄存器来存放栈的地址，还有专有的命令来压栈和出栈，这就决定了栈的效率比较高。堆则是由C或者C++的库函数或者运算符来申请和释放的，实现的机制比较复杂，频繁的内存申请与释放容易产生内存碎片。显然，堆的效率要比栈的效率低。

### 说说内存泄漏

内存泄漏简单来说就是资源申请了之后没有释放

造成的问题：如果申请了之后没有释放掉内存，那么时间长了之后，系统中能够使用的内存就越来越少，最终会因为内存不够而导致程序崩溃。

导致内存泄漏的操作由：

申请了内存之后不释放

拥有继承关系的类中没有虚析构函数

类中有成员变量指针指向堆区内存，但是没有析构函数或者析构函数中没有指针所指向的内存

如何解决：

可以使用智能指针

谁分配的尽量由谁来释放，比如说在函数A中申请了一块堆区内存，那么尽量在函数A中进行释放，而不是到其他的地方之后再释放

new/delete  new[]/delete[] 配对使用

将分配的内存用链表来进行管理，申请内存之后就将内存放到链表当中，用完释放之后就在链表中删除



### 说说硬链接和软链接

inode是文件系统的索引节点，它里面包含了文件的相关信息

硬链接（inode)就相当于是一个指针，这个指针指向了物理硬盘的一个区块，如果有多个文件指向这个区块，如果有一个文件被删除，那么不会影响其他的区块。事实上文件系统维护了一个引用计数，如果当前区块的引用计数大于0，那么他就不会被删除。

软链接的inode和被链接的文件的inode不同，说明两个不是同一个文件，软链接的inode所指向的内容实际上是一个绝对路径，当用户访问这个文件时，路径会被替换成绝对路径。



### 操作系统如何申请以及管理内存的

操作系统使用brk和mmap两个系统调用来申请内存，现在的操作系统都是用虚拟内存来管理内存的，操作系统为每个进程分配一个独立的地址空间，这个地址空间是虚拟地址。虚拟地址与物理地址之间存在映射关系，通过页表寻址完成虚拟地址与物理地址的转换。



### 简述Linux系统的内核态和用户态，什么时候会进入内核态

内核态和用户态是操作系统的两种运行级别，内核态拥有最高权限，可以执行系统所有的命令，而用户态只能执行部分命令。

为什么要区分内核态和用户态呢？因为在系统中有一些命令是非常危险的，如果不加以区分，程序就很容易随意破坏系统从而导致系统崩溃。

有三种情况可以进入内核态，分别是系统调用，异常和设备中断。其中系统调用是主动的，异常和设备中断时被动的



### 简述一下LRU及其实现方式

LRU（Least Recently Use） 最近最少使用算法，这是一种缓存淘汰策略，用来淘汰最近最少使用的对象。

LRU是通过双链表和哈希表来实现的。

当一个向缓存中插入一个数据时，如果发现这个数据在存在，那么就直接将数据移动到链表头部，如果这个数据不存在，那么先查看缓存数据是否已经满了，如果满了就将链表末尾的数据删掉然后新建节点存放数据，并将节点插入到链表头部。

当向缓存中查找数据时，如果数据存在就将数据插入到链表头部，如果不存在就返回-1

这样一来，链表末端的节点就是最近最少访问的节点。



### 一个线程占多大内存

线程的大小是和系统栈的大小有关的，一般linux中系统栈的大小为8M或者10M，那么线程的大小最大也就为8M或者10M，当然，系统栈的大小也是可以手动调整的，这样的话，线程的大小也会随之改变。



### 什么是页表，为什么要有页表

页表是虚拟内存中的概念，虚拟内存在使用的使用要找到物理内存。那么如何找到一个物理内存呢？答案是通过一个映射表来反映虚拟地址和物理地址之间的关系。这个映射表就叫做页表。

我们在映射的时候不可能将一个一个单独的虚拟地址映射到物理地址上，如果这样子做，在32位的操作系统上，那么我们最少就需要4B * 2 * 2 ^ 32 = 2 ^ 35B = 32G的字节来当作映射表。那么这个映射表需要的内存空间比实际的内存空间还大。

所以我们就把一段连续的内存空间当作一页，每页的内存是4KB， 如果每页是4KB，那么我们的映射表就需要 2 * 4 * 2 ^ 20B = 8MB

的内存空间



### 简述一下操作系统的缺页异常

我们在调用malloc这个分配的内存函数时，分配的内存实际上是虚拟内存中的空间，分配的是磁盘上的空间，并不是物理内存中的空间。如果我们在调用这一块内存空间时，发现虚拟内存对应的地址没有在物理内存中，那么就会触发缺页异常。

触发缺页异常后操作系统会调用缺页异常处理器，将磁盘中的页面换入到物理内存当中，然后继续调用之前导致异常的指令。









