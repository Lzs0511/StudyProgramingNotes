## 动态内存

**allocator类**

allocator将内存分配和对象构造分离开来

allocator分配未构造的内存

allocator定义在memory头文件下

标准库allocator类及其算法:

```c++
allocator<T> p 构造一个allocator类

p.allocate(n) 分配一段原始的，未构造的内存

p.constructor(p, args) 在p所指的内存上构造一个T类型的对象

p.destory(p) 对p所指对象执行析构函数

p.deallocate(p, n) 从p开始释放n个对象， 这些对象必须先执行过destory
```

**拷贝和填空未初始化内存的算法**

b和e为迭代器， n为数量，b2为allocator类所分配的未初始化的空间, t为填充的值

```c++
uninitialized_copy(b, e, b2) 用 b-e中的元素拷贝到b2中

uninitialized_copy_n(b, n, b2) 把从b开始的n个对象拷贝到b2中

uninitialized_fill(b, e, t) 将t的拷贝填充到b-e上

uninitialized_fill_n(b, n, t) 和copy_n差不多
```



## 第13章 拷贝控制

#### 析构函数

类的析构函数分为两部分，先是执行析构函数体，然后再销毁成员。成员的销毁是在析构函数体执行之后隐含的析构阶段中被销毁的。

如果一个类需要析构函数，那么它几乎肯定需要自定义的拷贝构造函数和拷贝复制运算符

需要拷贝操作的类也需要赋值操作，反之亦然

需要自定义拷贝构造函数和拷贝复制运算符，不一定意味着也需要析构函数（比如让每个新的对象的序号不同，拷贝时让序号加1，此时不需要析构函数）

#### 使用default

我们可以使用=default来让编译器为我们合成一个默认/拷贝/析构函数， =default只能用在具有合成版本的函数（默认构造，拷贝构造，拷贝复制、析构）后面

类内使用=default生成的是内联函数，如果想生成非内联函数，则应在类外的第一后面使用=default

#### 阻止拷贝

有的类可能不需要拷贝构造或者拷贝赋值运算符，比如iostream类，如果该类定义了拷贝构造或者拷贝赋值运算符，那么就可能出现多个对象写入或者读取相同的缓冲。在这些类中，合成的拷贝或者拷贝赋值运算符都不应该提供。

我们可以在拷贝构造函数或者拷贝赋值运算符后面加上 =delete 来将它定义为删除的， 以此来阻止拷贝和赋值

delete必须出现在第一次声明的时候，delete与default不同，default只用能在能够合成的函数中，而delete可以用在任何函数中。虽然delete的主要的用途是来组织拷贝和赋值，但是它也可以用在引导函数匹配过程中（P450)



析构函数不能是被删除的函数

如果析构函数被定义为删除的函数，那么就不能销毁该类的对象了。对于一个删除析构函数的类，编译器不允许定义该类型的变量或者临时对象。

如果一个对象中包含了被删除析构函数的成员，那么也不能定义该类的对象，因为成员销毁不了，该类的对象也不能销毁

虽然不能定义这种类的对象，但可以动态分配这种类型的对象，但是这种对象不能被释放。

```c++
struct NoDtor{
    NoDtor() = default;
    ~NoDtor() = delete;
};
NoDtor nd; // 错误， NoDtor的析构函数是删除的
NoDtor *p = new NoDtor(); // 正确： 但是我们不能delete p
delete p; // 错误： NoDtor的析构函数是删除的
```



合成的拷贝控制成员有可能是删除的：

如果有一个类的成员不能够默认构造、拷贝、赋值或者销毁，那么对应的成员函数将被定义为删除的。

比如一个类的成员A的拷贝赋值运算符被删除或者不可访问（private）那么，在复制该对象时，就不能复制该类中成员A，所以拷贝赋值运算符就没办法运行。



注：旧版本中，类通过将拷贝控制成员设置为私有（private）来删除拷贝控制成员，但是该类的友元依然可以访问该控制成员，只声明拷贝控制函数，不定义，这样可以防止友元使用私有拷贝控制函数。因为在友元使用拷贝控制函数时，会找不到拷贝控制函数的符号（链接时出错）



### 13.2拷贝控制和资源管理

#### 13.2.1 行为像值的类

赋值运算符通常组合了析构函数的构造函数的操作。比如在赋值时，需要销毁左侧对象原来的值，然后将右侧对象的值拷贝到左侧对象中

先拷贝右侧对象，可以处理自赋值的情况。

例：

```c++
HasPtr &operator=(const Hasptr &rhs) {
    auto newp = new string(*rhs.ps);
    delete ps; // 释放旧内存
    ps = newp;
    i = rhs.i;
    return *this;
}
```



关键：

1. 编写赋值运算符时，如果将它自身赋值给自己，要保证能够正确运行
2. 大多数赋值操作会组合析构函数和拷贝构造函数的工作







